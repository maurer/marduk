context_enable(bool)

live_mult {free: Loc, stacked: Loc}
live_mult_promote: live_mult {free, stacked} <- live {loc: stacked} + context::strip_stack

malloc_mult: malloc_call {loc: stacked} <- malloc_call {loc: free} & live_mult {free, stacked}
free_mult: free_call {loc: stacked, args} <- free_call {loc: free, args} & live_mult {free, stacked}
//returning_mult: returning_call {loc: stacked} <- returning_call {loc: free} & live_mult {free, stacked}
lift_mult: lift {loc: stacked, bil, fallthrough: fallthrough_stacked, disassembly, is_call, is_ret} <- lift {loc: free, bil, fallthrough, disassembly, is_call, is_ret} & live_mult {free, stacked} + context::stack_fallthrough
pad_mult: link_pad {pad_loc: stacked, pad_name} <- link_pad {pad_loc: free, pad_name} & live_mult {free, stacked}
//TODO: does var need to be promoted here?
func_uses_mult: func_uses(var, stacked) <- live_mult {free, stacked} & func_uses(var, free)

// TODO: check whether I need a layer of indirection here
// I'm overloading sym to seed live with a set of stack-sensitive starts
// This might make call_site_dyn tricker (or easier)
// TODO maybe bother to stack end
context_enable: sym {loc: stacked, name, end} <- context_enable(~true) & sym {loc: free, name, end} + context::add_stack
sym_mult: sym {loc: stacked, name, end} <- live_mult {free, stacked} & sym {loc: free, name, end}
