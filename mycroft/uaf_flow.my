// If we call into the PLT, register this call as skippable if it's not defined
skip_dyn: skip_func { file_name: name, addr: addr } <- link_pad { file_name: name, pad_name, pad_addr: tgt } & succ {file_name: name, src_addr: addr, dst_addr: tgt, is_call: ~true} & all_funcs { names } + ::funcs::exclude_names

// Begin alias tracking anywhere we see a malloc call
flow_start_malloc@2: path_alias {initial_file: file, initial_addr: addr, alias_set: ~ZERO, stack: ~(new_stack()), chop: ~(new_chop()), current_file: file, current_addr: step, aliased_var: ~(::avar::get_ret()), freed: ~false} <- malloc_call {file_name: file, addr: addr} & lift {file_name: file, address: addr, fallthrough: step}

// Also start tracking values moved off the heap
flow_start_heap: path_alias {initial_file: file, initial_addr: addr, alias_set: a_s, stack: ~(new_stack()), chop: ~(new_chop()), current_file: file, current_addr: step, aliased_var: heap_var, freed: ~false} <- lift {file_name: file, address: addr, fallthrough: step, bil: sema} + ::funcs::heap_init

// If we see a free, mark all aliased values as potentially freed
flow_free: path_alias {initial_file: file0, initial_addr: addr0, alias_set: alias_set, stack: stack, chop: chop, current_file: free_file, current_addr: next, aliased_var: a_var, freed: ~true} <- path_alias {initial_file: file0, initial_addr: addr0, alias_set: alias_set, stack: stack, chop: chop, current_file: free_file, current_addr: free_addr, aliased_var: ~(::avar::get_arg0())} & lift {file_name: free_file, address: free_addr, fallthrough: next} & free_call {file_name: free_file, addr: free_addr} & path_alias {initial_file: file0, initial_addr: addr0, alias_set: alias_set, stack: stack, chop: chop, current_file: free_file, current_addr: free_addr, aliased_var: a_var}

// As a hack for qfree, do the same as flow_free with the second argument
// TODO: Use summaries to handle qfree separately
flow_free2_hack: path_alias {initial_file: file0, initial_addr: addr0, alias_set: alias_set, stack: stack, chop: chop, current_file: free_file, current_addr: next, aliased_var: a_var, freed: ~true} <- path_alias {initial_file: file0, initial_addr: addr0, alias_set: alias_set, stack: stack, chop: chop, current_file: free_file, current_addr: free_addr, aliased_var: ~(::avar::get_arg_n(1))} & lift {file_name: free_file, address: free_addr, fallthrough: next} & free_call {file_name: free_file, addr: free_addr} & path_alias {initial_file: file0, initial_addr: addr0, alias_set: alias_set, stack: stack, chop: chop, current_file: free_file, current_addr: free_addr, aliased_var: a_var}

// Propagate may_alias relation through a block
flow_prop: path_alias {initial_file: file0, initial_addr: addr0, alias_set: a_s, stack: stack, chop: chop, current_file: file, current_addr: next, aliased_var: a_var2, freed: freed} <- path_alias {initial_file: file0, initial_addr: addr0, alias_set: a_s, stack: stack, chop: chop, current_file: file, current_addr: addr, aliased_var: a_var, freed: freed} & lift {file_name: file, address: addr, bil: bil} & succ {file_name: file, src_addr: addr, dst_addr: next, is_call: ~false} + ::funcs::xfer_taint

// If we would call a skippable function, act as though non-aliased data was written to all clobbered values
flow_skip_func: path_alias {initial_file: file0, initial_addr: addr0, alias_set: a_s, stack: stack, chop: chop, current_file: file, current_addr: next, aliased_var: a_var, freed: freed} <- path_alias {initial_file: file0, initial_addr: addr0, alias_set: a_s, stack: stack, chop: chop, current_file: file, current_addr: addr, aliased_var: a_var, freed: freed} & skip_func { file_name: file, addr: addr} & lift {file_name: file, address: addr, fallthrough: next} + ::funcs::clobbers

// If we call a non-skipped function, update the stack so we return properly, and follow the call
flow_call: path_alias {initial_file: file0, initial_addr: addr0, alias_set: a_s, stack: stack2, chop: chop2, current_file: file2, current_addr: addr2, aliased_var: a_var, freed: freed} <- path_alias {initial_file: file0, initial_addr: addr0, alias_set: a_s, stack: stack, chop: chop, current_file: file1, current_addr: addr1, aliased_var: a_var, freed: freed} & call_site {call_file: file1, call_addr: addr1, dst_file: file2, dst_addr: addr2} & lift {file_name: file1, address: addr1, fallthrough: ret_addr} + ::funcs::call_stack_chop

// If we return and have a stack, use the stack to get our return target
flow_ret: path_alias {initial_file: file0, initial_addr: addr0, alias_set: a_s, stack: stack2, chop: chop, current_file: file2, current_addr: addr2, aliased_var: a_var, freed: freed} <- path_alias {initial_file: file0, initial_addr: addr0, alias_set: a_s, stack: stack, chop: chop, current_file: file1, current_addr: addr1, aliased_var: a_var, freed: freed} & lift {file_name: file1, address: addr1, is_ret: ~true} + ::funcs::ret_stack

// If we return and have an empty stack, return to any call site in the program
flow_ret_notarget: path_alias {initial_file: file0, initial_addr: addr0, alias_set: a_s, stack: ~(new_stack()), chop: chop2, current_file: call_file, current_addr: dst_addr, aliased_var: a_var, freed: freed} <- path_alias {initial_file: file0, initial_addr: addr0, alias_set: a_s, stack: ~(new_stack()), chop: chop, current_file: file1, current_addr: addr1, aliased_var: a_var, freed: freed} & lift {file_name: file1, address: addr1, is_ret: ~true} & lift {file_name: call_file, address: call_addr, fallthrough: dst_addr} & call_site {call_file: call_file, call_addr: call_addr, dst_file: file1, dst_addr: func_addr} & func {file_name: file1, entry: func_addr, addr: addr1} + ::funcs::ret_no_stack

// If a freed pointer is used either to read or write, mark a use-after-free-flow
flow_final: use_after_free_flow {initial_file: file0, initial_addr: addr0, alias_set: a_s, stack: stack, final_file: file1, final_addr: addr1, loc: a_var} <- path_alias {initial_file: file0, initial_addr: addr0, alias_set: a_s, stack: stack, chop: chop, current_file: file1, current_addr: addr1, aliased_var: a_var, freed: ~true} & lift {file_name: file_1, address: addr1, bil: bil} + ::funcs::flow_use
