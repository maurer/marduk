reaching {
	def: Loc,
	register: Reg,
	reached: Loc
}

// This predicate currently confuses may_define and must_define.
// When used in reaching_init, it's used as may_define
// When used in reaching_trans, it's used as must_define
// ::use_def::defines creates may_define
// If this turns out to be problematic, I can produce both

defines {
	loc: Loc,
	registers: Regs
}

// Write down what a semantics chunk overwrites
define_sema: defines {loc, registers} <- lift {loc, bil, is_call: ~false} + ::use_def::defines
define_funcs: defines {loc, registers: ~(::regs::caller_saved())} <- lift {loc, is_call: ~true}

// Killsets
kill(Loc, KillSpec)
kill_registers: kill(loc, ks) <- lift {loc, is_ret: ~false} & defines {loc, registers} + ::use_def::killspec_regs
kill_ret: kill(loc, ks) <- lift {loc, is_ret: ~true} & func {base, contains: loc} + ::use_def::stack_wipe

succ_ret{src: Loc, dst: Loc}
func_ret{ret: Loc, func: Loc}
resolve_rets: func_ret{ret, func} <- lift {loc: ret, is_ret: ~true} & func {base: func, contains: ret}
ret_flat@1: succ_ret {src, dst} <- func_ret{ret: src, func} & call_site {target_loc: func, ret_loc: dst}
succ_call{src: Loc, dst: Loc}
call_flat: succ_call {src, dst} <- succ {src, is_call: ~true} & call_site{call_loc: src, target_loc: dst}

succ_any{src: Loc, dst: Loc}
promote_over: succ_any{src, dst} <- succ_over {src, dst}
promote_ret: succ_any{src, dst} <- succ_ret{src, dst}
promote_call: succ_any{src, dst} <- succ_call{src, dst}

?defines: defines {loc, registers}
