impossible (bool)
reaching {
	file: String,
	def_addr: BitVectorSet^union,
	register: String,
	reached_addr: BitVector
}

// This predicate currently confuses may_define and must_define.
// When used in reaching_init, it's used as may_define
// When used in reaching_trans, it's used as must_define
// ::funcs::defines creates may_define
// If this turns out to be problematic, I can produce both

defines {
	file: String,
	addr: BitVector,
	registers: Strings
}

// Write down what a semantics chunk overwrites
define_sema: defines {file, addr, registers} <- lift {file_name: file, address: addr, bil} + ::funcs::defines

// If we define some registers, then our definition reaches all our immediate successors
reaching_init: reaching {file, def_addr: def_addr_singleton, register, reached_addr} <- defines {file, addr: def_addr, registers} & succ_over {file_name: file, src: def_addr, dst: reached_addr} + ::funcs::expand_registers

// If a definition reaches an instruction, and that instruction does not overwrite the register, it proceeds to the next one 
reaching_trans@2: reaching {file, def_addr, register, reached_addr} <- reaching {file, def_addr, register, reached_addr: prev_reached_addr} & succ_over { file_name: file, src: prev_reached_addr, dst: reached_addr } & defines {file, addr: prev_reached_addr, registers: prev_defines} + ::funcs::exclude_registers

?defines: defines {file, addr, registers}
?reaching: reaching {file, def_addr, register, reached_addr}

// Merge defchains together when done
partial_chain(BitVector, DefChain^chain_merge)
chain(BitVector, DefChain)

promote_chain@3: partial_chain(addr, dc) <- ~reaching {def_addr, reached_addr: addr, register} + ::funcs::def_chain
def_done@4: chain(bv, dc) <- ~partial_chain(bv, dc)
