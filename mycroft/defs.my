reaching {
	defs: LocSet^union,
	register: String,
	reached: Loc
}

// This predicate currently confuses may_define and must_define.
// When used in reaching_init, it's used as may_define
// When used in reaching_trans, it's used as must_define
// ::funcs::defines creates may_define
// If this turns out to be problematic, I can produce both

defines {
	loc: Loc,
	registers: Strings
}

// Write down what a semantics chunk overwrites
define_sema: defines {loc, registers} <- lift {loc, bil} + ::funcs::defines
// Malloc defines rax
define_malloc: defines {loc, registers: ~(vec!["RAX".to_string()])} <- malloc_call {loc}

// If we define some registers, then our definition reaches all our immediate successors
reaching_init: reaching {defs: def_loc_singleton, register, reached} <- defines {loc: def_loc, registers} & succ_over {src: def_loc, dst: reached} + ::funcs::expand_registers

// If a definition reaches an instruction, and that instruction does not overwrite the register, it proceeds to the next one 
reaching_trans@2: reaching {defs, register, reached} <- reaching {defs, register, reached: prev_loc} & succ_over {src: prev_loc, dst: reached } & defines {loc: prev_loc, registers: prev_defines} + ::funcs::exclude_registers

?defines: defines {loc, registers}
?reaching: reaching {defs, register, reached}

// Merge defchains together when done
partial_chain(Loc, DefChain^chain_merge)
chain(Loc, DefChain)

promote_chain@3: partial_chain(reached, dc) <- ~reaching {defs, reached, register} + ::funcs::def_chain
def_done@4: chain(bv, dc) <- ~partial_chain(bv, dc)
