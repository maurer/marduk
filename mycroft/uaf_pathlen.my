path_alias_trace {
    initial_file: String,
    initial_addr: BitVector,
    alias_set: usize,
    chop: Chop,
    stack: Stack,
    current_file: String,
    current_addr: BitVector,
    aliased_var: AVar,
    freed: bool^or,
    steps: usize
}

use_after_free {
    initial_file: String,
    initial_addr: BitVector,
    alias_set: usize,
    stack: Stack,
    final_file: String,
    final_addr: BitVector,
    loc: AVar,
    steps: usize
}

// Begin alias tracking anywhere we found a use after free in the flow analysis from malloc
path_start_malloc: path_alias_trace {initial_file, initial_addr, alias_set: ~ZERO, stack: ~(new_stack()), chop: ~(new_chop()), current_file: initial_file, current_addr, aliased_var, freed: ~false, steps: ~ZERO} <- path_alias {initial_file, initial_addr, alias_set: ~ZERO, current_file: initial_file, current_addr, aliased_var} & use_after_free_flow {initial_file, initial_addr, alias_set: ~ZERO} & lift {file_name: initial_file, address: initial_addr, fallthrough: current_addr}

// If it came from the heap, we need to redo the heap propagation - the alias set already in the path_alias predicate is too big
path_start_heap: path_alias_trace {initial_file, initial_addr, alias_set, stack: ~(new_stack()), chop: ~(new_chop()), current_file: initial_file, current_addr, aliased_var: heap_var, freed: ~false, steps: ~ZERO} <- use_after_free_flow {initial_file, initial_addr, alias_set} & lift {file_name: initial_file, address: initial_addr, bil: sema, fallthrough: current_addr} + ::funcs::path_start_heap

// If we see a free, mark all aliased values as potentially freed
path_free: path_alias_trace {initial_file: file0, initial_addr: addr0, alias_set: alias_set, stack: stack, chop: chop, current_file: free_file, current_addr: next, aliased_var: a_var, freed: ~true, steps: steps_plus_one} <- path_alias_trace {initial_file: file0, initial_addr: addr0, alias_set: alias_set, stack: stack, chop: chop, current_file: free_file, current_addr: free_addr, aliased_var: ~(::avar::get_arg0()), steps} & lift {file_name: free_file, address: free_addr, fallthrough: next} & free_call {file_name: free_file, addr: free_addr} & path_alias_trace {initial_file: file0, initial_addr: addr0, alias_set: alias_set, stack: stack, chop: chop, current_file: free_file, current_addr: free_addr, aliased_var: a_var, steps} + ::funcs::inc_path

// As a hack for qfree, do the same as flow_free with the second argument
// TODO: Use summaries to handle qfree separately
path_free2_hack: path_alias_trace {initial_file: file0, initial_addr: addr0, alias_set: alias_set, stack: stack, chop: chop, current_file: free_file, current_addr: next, aliased_var: a_var, freed: ~true, steps: steps_plus_one} <- path_alias_trace {initial_file: file0, initial_addr: addr0, alias_set: alias_set, stack: stack, chop: chop, current_file: free_file, current_addr: free_addr, aliased_var: ~(::avar::get_arg_n(1)), steps} & lift {file_name: free_file, address: free_addr, fallthrough: next} & free_call {file_name: free_file, addr: free_addr} & path_alias_trace {initial_file: file0, initial_addr: addr0, alias_set: alias_set, stack: stack, chop: chop, current_file: free_file, current_addr: free_addr, aliased_var: a_var, steps} + ::funcs::inc_path2

// Propagate may_alias relation through a block
path_prop: path_alias_trace {initial_file: file0, initial_addr: addr0, alias_set: a_s, stack: stack, chop: chop, current_file: file, current_addr: next, aliased_var: a_var2, freed: freed, steps: steps_plus_one} <- path_alias_trace {initial_file: file0, initial_addr: addr0, alias_set: a_s, stack: stack, chop: chop, current_file: file, current_addr: addr, aliased_var: a_var, freed: freed, steps} & lift {file_name: file, address: addr, bil: bil} & succ {file_name: file, src_addr: addr, dst_addr: next, is_call: ~false} + ::funcs::xfer_taint_trace

// If we would call a skippable function, act as though non-aliased data was written to all clobbered values
path_skip_func: path_alias_trace {initial_file: file0, initial_addr: addr0, alias_set: a_s, stack: stack, chop: chop, current_file: file, current_addr: next, aliased_var: a_var, freed: freed, steps} <- path_alias_trace {initial_file: file0, initial_addr: addr0, alias_set: a_s, stack: stack, chop: chop, current_file: file, current_addr: addr, aliased_var: a_var, freed: freed, steps} & skip_func { file_name: file, addr: addr} & lift {file_name: file, address: addr, fallthrough: next} + ::funcs::clobbers_trace

// If we call a non-skipped function, update the stack so we return properly, and follow the call
path_call: path_alias_trace {initial_file: file0, initial_addr: addr0, alias_set: a_s, stack: stack2, chop: chop2, current_file: file2, current_addr: addr2, aliased_var: a_var, freed: freed, steps} <- path_alias_trace {initial_file: file0, initial_addr: addr0, alias_set: a_s, stack: stack, chop: chop, current_file: file1, current_addr: addr1, aliased_var: a_var, freed: freed, steps} & call_site {call_file: file1, call_addr: addr1, dst_file: file2, dst_addr: addr2} & lift {file_name: file1, address: addr1, fallthrough: ret_addr} + ::funcs::call_stack_chop_trace

// If we return and have a stack, use the stack to get our return target
path_ret: path_alias_trace {initial_file: file0, initial_addr: addr0, alias_set: a_s, stack: stack2, chop: chop, current_file: file2, current_addr: addr2, aliased_var: a_var, freed: freed, steps} <- path_alias_trace {initial_file: file0, initial_addr: addr0, alias_set: a_s, stack: stack, chop: chop, current_file: file1, current_addr: addr1, aliased_var: a_var, freed: freed, steps} & lift {file_name: file1, address: addr1, is_ret: ~true} + ::funcs::ret_stack_trace

// If we return and have an empty stack, return to any call site in the program
path_ret_notarget: path_alias_trace {initial_file: file0, initial_addr: addr0, alias_set: a_s, stack: ~(new_stack()), chop: chop2, current_file: call_file, current_addr: dst_addr, aliased_var: a_var, freed: freed, steps} <- path_alias_trace {initial_file: file0, initial_addr: addr0, alias_set: a_s, stack: ~(new_stack()), chop: chop, current_file: file1, current_addr: addr1, aliased_var: a_var, freed: freed, steps} & lift {file_name: file1, address: addr1, is_ret: ~true} & lift {file_name: call_file, address: call_addr, fallthrough: dst_addr} & call_site {call_file: call_file, call_addr: call_addr, dst_file: file1, dst_addr: func_addr} & func {file_name: file1, entry: func_addr, addr: addr1} + ::funcs::ret_no_stack_trace

// If a freed pointer is used either to read or write, mark a use-after-free-flow
path_final: use_after_free {initial_file: file0, initial_addr: addr0, alias_set: a_s, stack: stack, final_file: file1, final_addr: addr1, loc: a_var, steps} <- path_alias_trace {initial_file: file0, initial_addr: addr0, alias_set: a_s, stack: stack, chop: chop, current_file: file1, current_addr: addr1, aliased_var: a_var, freed: ~true, steps} & lift {file_name: file_1, address: addr1, bil: bil} + ::funcs::trace_use
